#! /usr/bin/env python

import basic

class DAGError(Exception):
    pass

def _topological_visit(node, results, visited, call_stack=None):
    """Recursively visits the descendants of a node and appends them
    to the results.  For the initial caller, the call_stack argument should
    be None.  A call_stack set will be generated by the first call to keep
    track of nodes visited during the current recursion for cycle detection.

    Parameters
    ----------
    node: a valid vgraph Node object to begin the DFS
    results: the list of results
    visited: a set of all nodes visited across the entire sort operation
    call_stack: a set of all nodes visited during the current recursion

    Returns
    -------
    None"""    
    #if we're at the top of a stack of recursive calls, initialize
    #a set of visited nodes for this stack to detect cycles
    if not call_stack:
        call_stack = set()
    if node in call_stack:
        raise DAGError('Graph contains a cycle')
    if node not in visited:
        call_stack.add(node)
        visited.add(node)
        for edge in node.edges(outgoing=True, incoming=False):
            _topological_visit(edge.node_2, results, visited, call_stack=call_stack)
        #as we come out of the recursion, nodes need to be "backed in"
        #to the results rather than simply appended
        results.insert(0, node)

def topological(graph=None, source=None):
    """Implements a depth-first search strategy for topologically
    sorting a directed acyclic graph (DAG).  This algorithm returns
    the first solution it finds and does not test alternates.  If
    the graph contains a cycle, it will raise a DAGError.  Either one
    of "graph" or "source" must not be None.  If a source is supplied
    without a graph, a breadth-first search will be generated first
    to find the node's subgraph.

    Parameters
    ----------
    graph: a valid vgraph Graph object
    source: a valid vgraph Node object
    
    Returns
    -------
    A list of sorted nodes"""
    results = []
    start_nodes = set()
    visited = set()

    if graph:
        nodes = graph.nodes()
    else:
        nodes = basic.BFS(source)       

    for n in nodes:
        if n.edges(incoming=True, outgoing=False):
            continue
        _topological_visit(n, results, visited)
    return results
            